---
title: "HW4"
author: "Sokona Mangane"
date: "2023-02-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

# Unifrom Random Variates:

1.  Write an R function names `myunif` that accepts three parameters: n, the number of variates to generate; a, the lower limit of the distribution; and b, the upper limit of the distribution.

Your function must return a vector of *n* uniform *(a, b)* random variates. Each variate must be generated by inverting a single call to runif(1) --- use the idf determined by setting u = F (x) and solving for x (you are not permitted to use quniif).

```{r q1}

myunif <- function(n, a, b){
  values = rep(0,n)
  for(i in 0:n){
    values[i] = a + ((b-a)*(runif(1)))
  }
  return(values)
}

a = 0
b = 1000
n = 1000

hist(myunif(n, a, b))
```

2.  Using your myunif function, produce a histogram of many uniform (a, b) random variates, superimposing the true theoretical distribution (see dunif).

```{r q2}

histdata = myunif(10000, 10, 20)
x <- seq(10,20, by = 0.01)
hist(histdata, freq = FALSE)
curve(dunif(x, 10, 20), add = TRUE)

```

3.  Confirm that the mean and standard deviation of your random variate sample are consistent with the theoretical values given above

```{r q3}
tmean = (a + b)/2 #theoretical mean
tsd = (b - a) / sqrt(12) #theoretical sd

mean(histdata) == tmean
sd(histdata) == tsd

```
Even though the values say FALSE, the mean is of our sample, `r mean(histdata)`, is a few points off, but very close to the theoretical mean, `r print(tmean)`. The standard deviation of our sample, `r sd(histdata)`, is almost identical to the theoretical standard deviation of `r print(tsd)`.


# Triangular Random Variates

Often, the only data known about a real-world distribution is its minimum value, its maximum value, and its most likely value (mode). In such a case, the triangular distribution is appropriate. Let the random variable X be triangular (a, b, c) where a is the minimum value, b is the maximum value, and c is the mode.

4.  Write an R function named mytriang that accepts four parameters: n, the number of variates to generate; a, the lower limit of the distribution; b, the upper limit of the distribution; and c, the mode of the distribution.

Your function must return a vector of n triangular (a, b, c) random variates. Each variate must be generated by inverting a single call to runif(1) using the idf you determined above.

```{r q4}

mytriang <- function(n, a, b, c){
  values = rep(0,n)
  if(a < runif(1) & runif(1) < c) {
    for(i in 0:n){
      d = (b - a)*(c - a)
      values[i] = a - (sqrt(d * runif(1)))
    }
    
  if(c < runif(1) & runif(1) < b) {
    for (i in 0:n) {
      values[i] = b - ((b-a)*runif(1))
      }
  }
  }
  return(values)
}

a = 0
b = 1000
c = 500
n = 1000

hist(mytriang(n, a, b, c), freq = FALSE) #is the histogram supposed to look like a triangle? and why are thex limits from -500 to 0?
```

5.  Using your mytriang function, produce a histogram of many triangular (a, b, c) random variates, superimposing the true theoretical distribution (use the segments function in R to plot your derived f(x) equation from above).

```{r q5}

histdata1 = mytriang(10000, 10, 25, 15)

x <- seq(10,20, by = 0.01)
hist(histdata1, freq = FALSE) #looks like a uniform distribution from -1 to 0
# segements() #???
# curve(dunif(x, 10, 20), add = TRUE) #theoretical distribution for the triangular distribution?

```

6.  Confirm that the mean and standard deviation of your random variate sample are consistent with the theoretical values given below.


Even though the values say FALSE, the mean is of our sample, `r #mean(histdata1)`, is a few points off, but very close to the theoretical mean, `r #print(ttriangmean)`. The standard deviation of our sample, `r #sd(histdata1)`, is almost identical to the theoretical standard deviation of `r #print(ttriangsd)`.

```{r q6}
# ttriangmean = (a + b + c)/3 #theoretical triangular mean
# ttriangsd = sqrt((1/18) * ((a^2) + (b^2) + (c^2) - (a*b) - (a*c) - (b*c))) #theoretical triangular sd
# 
# mean(histdata1) == ttriangmean
# 
# sd(histdata1) == ttriangsd
# 

```


